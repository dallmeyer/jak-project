(def-actor my-actor
  :bounds (0 0 0 5)
  :texture-level 2)

(deftype my-actor (process-drawable)
  ((root collide-shape-moving :override))
  (:methods
   (init-collision! (_type_) none))
  (:state-methods
   idle))

(defbehavior my-actor-init-by-other my-actor ((trans vector) (quat quaternion))
  (stack-size-set! (-> self main-thread) 128)
  (init-collision! self)
  (process-mask-clear! (-> self mask) actor-pause)
  (vector-copy! (-> self root trans) trans)
  (quaternion-copy! (-> self root quat) quat)
  (initialize-skeleton self *my-actor-sg* '())
  (go-virtual idle))

(defmethod init-collision! ((this my-actor))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 1) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 0)
      (set-vector! (-> cgroup local-sphere) 0.0 0.0 0.0 (meters 5))
      (set-root-prim! cshape cgroup)
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 0)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 5))
        (append-prim cgroup mesh)))
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape))
  (none))

(defstate idle (my-actor)
  :virtual #t
  ;; virtual state
  :code
  (behavior ()
    (loop
      (suspend)))
  :post transform-post
  ;; run the transform-post handler which updates our root transform every frame
  )
